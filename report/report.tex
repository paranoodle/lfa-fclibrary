\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\bibliographystyle{plainnat}
\usepackage{url}

\setlength{\parskip}{1em}

\title{Fuzzy Clustering Library}
\date{13.5.2016}
\author{Eléonore d'Agostino et Benoît Zuckschwerdt}

\begin{document}
  \pagenumbering{arabic}
  \maketitle
  \tableofcontents
  \newpage

  \section{Introduction}

  \section{Contexte}

    Le \textit{Clustering} consiste à prendre un ensemble de données, et à le diviser en groupes, ou \textit{clusters}.

    \subsection{Fuzzy Clustering}

      Aussi connu sous le nom de \textit{Soft Clustering}, le Fuzzy Clustering, à la différence du \textit{Hard Clustering}, permet à un point d'appartenir à zero où plusieurs clusters, et d'avoir un degré d'appartenance à chacun des clusters du système.

    \subsection{Algorithme K-means}

      Algorithme de hard clustering, K-means est l'algorithme de clustering le plus basique. Il génère des fonctions d'appartenance binaires, ne permettant que des valeurs de 1 (appartient au cluster) ou 0 (n'appartient pas au cluster).
      
      Le concept derrière K-means est de partitionner un ensemble d'observations $(x_1,x_2,...,x_n)$ de manière à minimiser le \textbf{WCSS}, où \textit{Within-Cluster Sum of Squares} (Somme des carrés interne au cluster), dont la formule est $\sum_{i=1}^{k}\sum_{x\in S_i}||x-\mu_i||^2$, où $\mu_i$ est la moyenne des points dans chaque cluster.
      
      L'algorithme standard de K-means, aussi connu sous le nom d'\textit{Algorithme de Lloyd}, fonctionne en alternant entre deux étapes, avec $m_1^{(1)},...,m_k^{(t)}$ l'ensemble initial de $k$ moyennes:
      
      L'étape \textbf{d'assignement} lie chaque observation $x_p$ au cluster dont la moyenne donne le WCSS minimal. Ceci correspond à partitionner les observations suivant le diagramme de Voronoi généré par les moyennes: chaque $x_p$ est assigné à un $S^{(t)}$, avec $S_i^{(t)}=\{x_p:||x_p-m_i^{(t)}||^2\leq ||x_p-m_j^{(t)}||^2\forall j,1\leq j\leq k\}$
      
      L'étape de \textbf{mise à jour} calcule des nouvelles moyennes correspondant au centres géométriques des nouveaux clusters, en minimisant le WCSS. On a alors $m_i^{(t+1)}=\frac{1}{|S_i^{(t)}|}\sum_{x_j\in S_i^{(t)}}x_j$
      
      Dès qu'on atteint une itération où l'étape de mise à jour ne modifie plus de valeurs, l'algorithme se termine.
      
      Par contre, l'algorithme K-means doit être initialisé avec deux informations: le nombre de clusters désirés, ainsi que les moyennes initiales pour chacun de ses clusters. Dans le cas le plus simple, les moyennes initiales sont obtenues au hasard parmis les observations déjà présentes.
      
      \subsubsection{K-means++}

    \subsection{Algorithme Fuzzy C-means}

    \subsection{Algorithmes Expectation-Maximization}

  \section{Etat de l'art}

  \subsection{Mathematica}

  Mathematica est un logiciel de calcul édité par Wolfram Research. Il possède une implémentation de C-means.

  \subsection{MATLAB}

  MATLAB est un language de programmation, il est utilisé à des fins de calculs numériques.

  Fuzzy C-Means Clustering et Subtractive Clustering -> http://ch.mathworks.com/help/fuzzy/fuzzy-clustering.html?requestedDomain=www.mathworks.com

  \subsection{R}

  R est un logiciel libre de traitement de données et d'analyse statistique, il utilise le langage de programmation S.

  FANNY -> https://stat.ethz.ch/R-manual/R-devel/library/cluster/html/fanny.html

  \section{Réalisation}

  Nous allons développer nos fonctions en Python, ce choix nous semble le plus logique, vu que on utilise ce language dans ce cours.

  Pour commencer nous allons mettre en place K-means dont l'implémentation est plus simple que celle de C-means,
  cela nous permettra également de bien comprendre le fonctionnement des ces méthodes et par la suite de les comparer (C-means étant de la logique floue).

  Nous nous intéresseront ensuite aux algorithmes Expectation-Maximization.

  \section{Conclusion}

\bibliography{biblio}
\nocite{*}

\end{document}
